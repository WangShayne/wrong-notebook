# Global Rules for Antigravity Agent
1. **Language Requirement**:
   - You MUST use **Chinese (Simplified)** for ALL outputs.
   - This includes:
     - **Internal Thought Process & Reasoning** (MUST BE IN CHINESE).
     - Conversational responses.
     - Task summaries and status updates.
     - Artifact content (task.md, implementation_plan.md, walkthrough.md, etc.).
     - Code comments and documentation strings.
     - Commit messages (unless specified otherwise).
2. **Artifact Localization**:
   - Ensure specific terms in artifacts are translated appropriately (e.g., "Implementation Plan" -> "å®æ–½è®¡åˆ’", "Verification" -> "éªŒè¯").

# Git Commit Rules
1. **ğŸš« ä¸¥ç¦è‡ªåŠ¨æäº¤ä»£ç  (No Auto-Commit)**
   - **NEVER** automatically execute `git add` or `git commit` commands without explicit user confirmation.
   - When code changes are complete, you MUST:
     - Ask the user: "ä»£ç ä¿®æ”¹å·²å®Œæˆ,æ˜¯å¦éœ€è¦åˆ›å»º git æäº¤?"
     - Wait for user's explicit approval before proceeding.
   - Only execute git commands after receiving clear confirmation (e.g., "æ˜¯", "æäº¤", "commit", "å¥½çš„").

2. **æäº¤å‰å¿…é¡»å±•ç¤ºå˜æ›´æ‘˜è¦ (Show Changes Summary)**
   - Before committing, always run `git status` and `git diff` to show what will be committed.
   - Present a summary of changes to the user for review.

3. **æäº¤ä¿¡æ¯è§„èŒƒ (Commit Message Convention)**
   - Use conventional commit format: `<type>: <description>`
   - Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `ci`
   - Description must be clear and concise in Chinese.
   - **ğŸš« ä¸¥ç¦æ·»åŠ  AI å·¥å…·ç½²å (No AI Tool Attribution)**:
     - Do NOT add any Claude Code, AI assistant, or co-authorship references
     - Do NOT include lines like "Generated with Claude Code"
     - Do NOT add "Co-Authored-By: Claude" or similar attributions
     - Keep commit messages clean and professional without AI tool mentions
     - This prevents GitHub from showing AI tools as repository collaborators

# Front-end Internationalization (i18n) Rules
1. **ğŸš« ä¸¥ç¦ç¡¬ç¼–ç  (No Hardcoded Strings)**
   - All UI text (buttons, placeholders, titles, alerts, errors) MUST be extracted via translation objects (e.g., `t.section.key`).
   - Do NOT write hardcoded Chinese or English strings in JSX or business logic.
   - If a key is missing, add it to `translations.ts` first.

2. **ğŸŒ Fallback è¯­è¨€ç»Ÿä¸€ä¸ºè‹±æ–‡ (Consistent English Fallback)**
   - When providing fallback text (e.g., `t.key || 'Fallback'`), **ALWAYS use English**.
   - Example: `<Button>{t.common.save || 'Save'}</Button>` is correct.
   - Example: `<Button>{t.common.save || 'ä¿å­˜'}</Button>` is **PROHIBITED**.

# Responsive Design Rules (å“åº”å¼è®¾è®¡è§„åˆ™)
1. **ğŸ“± å¿…é¡»è€ƒè™‘ PC å’Œç§»åŠ¨ç«¯ (PC & Mobile Support Required)**
   - **ALL** UI/page modifications MUST support both desktop and mobile viewports.
   - When implementing features, you MUST:
     - Ask yourself: "è¿™ä¸ªè®¾è®¡åœ¨ç§»åŠ¨ç«¯å¦‚ä½•å‘ˆç°?"
     - Test layouts at common breakpoints: 320px (mobile), 768px (tablet), 1024px+ (desktop)
     - Use responsive design patterns (e.g., stacked layout on mobile, side-by-side on desktop)

2. **ğŸ¨ å“åº”å¼å®ç°è§„èŒƒ (Responsive Implementation Standards)**
   - **Use Tailwind responsive prefixes**: `sm:`, `md:`, `lg:`, `xl:` for breakpoint-specific styles.
   - **Mobile-first approach**: Write base styles for mobile, then override with `md:` and `lg:` for larger screens.
   - **Common patterns**:
     - Navigation: Hamburger menu on mobile, full navbar on desktop
     - Tables: Card view on mobile, table view on desktop
     - Forms: Full-width inputs on mobile, multi-column on desktop
     - Modals: Full-screen on mobile, centered dialog on desktop

3. **âš ï¸ ç§»åŠ¨ç«¯ç‰¹æ®Šè€ƒè™‘ (Mobile-Specific Considerations)**
   - **Touch targets**: Buttons/links should be at least 44px Ã— 44px (minimum tap size)
   - **Text readability**: Minimum font size 16px on mobile (prevents zoom on iOS)
   - **Spacing**: Use adequate padding/margin for touch-friendly interactions
   - **Performance**: Optimize images and avoid heavy animations on mobile

4. **âœ… ä¿®æ”¹å‰å¿…é¡»ç¡®è®¤ (Confirm Before Modifying)**
   - Before implementing page/component changes, you MUST ask:
     - "è¿™ä¸ªåŠŸèƒ½åœ¨ç§»åŠ¨ç«¯éœ€è¦ç‰¹æ®Šå¤„ç†å—?"
     - "ç§»åŠ¨ç«¯å’Œ PC ç«¯çš„å¸ƒå±€æ˜¯å¦éœ€è¦ä¸åŒ?"
   - If unclear, propose both mobile and desktop designs for user approval.

# Testing Rules (æµ‹è¯•è§„åˆ™)

1. **ğŸ”„ è‡ªåŠ¨åŒ–æµ‹è¯•è§¦å‘ (Automated Testing)**
   - After completing code modifications (without errors), automatically run tests based on change scope
   - Do NOT run `npm run build` unless explicitly requested by the user
   - Do NOT wait for user confirmation to run tests â€” this is an automated quality gate
   - Use smart triggers and tiered testing strategy (see below)

2. **ğŸ¯ æ™ºèƒ½æµ‹è¯•è§¦å‘ (Smart Test Triggers)**

   **è‡ªåŠ¨è¿è¡Œæµ‹è¯•** (éœ€è¦æµ‹è¯•çš„æƒ…å†µ):
   - ä¿®æ”¹ `.ts`ã€`.tsx` æºä»£ç æ–‡ä»¶
   - ä¿®æ”¹ API è·¯ç”± (`src/app/api/*`)
   - ä¿®æ”¹æ ¸å¿ƒåº“ä»£ç  (`src/lib/*`)
   - ä¿®æ”¹æ•°æ®åº“ç›¸å…³ä»£ç  (`prisma/*`)
   - ä¿®æ”¹ç»„ä»¶ä»£ç  (`src/components/*`)
   - ä¿®æ”¹æµ‹è¯•æ–‡ä»¶æœ¬èº« (`src/__tests__/*`)

   **è·³è¿‡æµ‹è¯•** (ä¸éœ€è¦æµ‹è¯•çš„æƒ…å†µ):
   - ä»…ä¿®æ”¹æ–‡æ¡£æ–‡ä»¶ (`.md`, `.txt`, `doc/*`)
   - ä»…ä¿®æ”¹é…ç½®ç¤ºä¾‹ (`.env.example`, `.gitignore`, `.cursorrulers`)
   - ä»…ä¿®æ”¹æ ·å¼æ–‡ä»¶ (`.css`, çº¯æ ·å¼è°ƒæ•´)
   - ä»…ä¿®æ”¹æ³¨é‡Šæˆ–ä»£ç æ ¼å¼åŒ– (ä¸æ”¹å˜é€»è¾‘)

   **ç”¨æˆ·ç¡®è®¤** (ä¸ç¡®å®šæ˜¯å¦éœ€è¦æµ‹è¯•æ—¶):
   - ä¿®æ”¹æ„å»ºé…ç½® (`package.json`, `tsconfig.json`, `next.config.js`)
   - ä¿®æ”¹æµ‹è¯•é…ç½® (`vitest.config.ts`, `playwright.config.ts`)

3. **ğŸš€ åˆ†çº§æµ‹è¯•ç­–ç•¥ (Tiered Testing Strategy)**

   **Level 1 - å¿«é€ŸéªŒè¯** (< 1ç§’):
   - é€‚ç”¨äº: å•ä¸ªå‡½æ•°/ç»„ä»¶å°æ”¹åŠ¨
   - è¿è¡Œ: ç›¸å…³çš„å•å…ƒæµ‹è¯•å­é›†
   - ç¤ºä¾‹: `vitest run src/__tests__/unit/utils.test.ts`

   **Level 2 - æ ‡å‡†éªŒè¯** (~3ç§’):
   - é€‚ç”¨äº: å¤šæ–‡ä»¶ä¿®æ”¹ã€æ–°åŠŸèƒ½å¼€å‘
   - è¿è¡Œ: å®Œæ•´å•å…ƒæµ‹è¯•
   - å‘½ä»¤: `npm run test:unit`

   **Level 3 - å®Œæ•´éªŒè¯** (~5ç§’) â­ **é»˜è®¤çº§åˆ«**:
   - é€‚ç”¨äº: API/æ•°æ®åº“ä¿®æ”¹ã€æ ¸å¿ƒé€»è¾‘å˜æ›´
   - è¿è¡Œ: å•å…ƒæµ‹è¯• + é›†æˆæµ‹è¯•
   - å‘½ä»¤: `npm run test:unit && npm run test:integration`

   **Level 4 - å‘å¸ƒå‡†å¤‡** (5-10åˆ†é’Ÿ):
   - é€‚ç”¨äº: å‡†å¤‡æäº¤ PRã€å‘å¸ƒå‰éªŒè¯
   - è¿è¡Œ: æ‰€æœ‰æµ‹è¯• + ç±»å‹æ£€æŸ¥ + æ„å»º
   - å‘½ä»¤: `npm run test && npm run build`
   - âš ï¸ **ä»…åœ¨ç”¨æˆ·æ˜ç¡®è¦æ±‚æ—¶è¿è¡Œ**

4. **ğŸ“Š æµ‹è¯•ç»“æœå¤„ç† (Test Results Handling)**
   - **If tests PASS**: Report success with summary and proceed
   - **If tests FAIL**:
     - Analyze the failure and attempt to fix the issue
     - Re-run the failed tests after fixing
     - Only report completion after ALL tests pass
   - Always show a clear summary of test results to the user:
     - Number of tests passed/failed
     - Execution time
     - Failed test details (if any)

5. **âš ï¸ æµ‹è¯•è¦†ç›–è¦æ±‚ (Test Coverage Requirements)**
   - When adding new features:
     - Write unit tests for new functions/classes
     - Write integration tests for new API routes
     - Update existing tests if behavior changes
   - When modifying existing code:
     - Ensure related tests still pass
     - Update tests if contracts change
     - Add tests for new edge cases
   - When fixing bugs:
     - Add a test that reproduces the bug
     - Verify the test fails before fix
     - Verify the test passes after fix

6. **ğŸ¯ æœ€ä½³å®è·µ (Best Practices)**
   - Prefer Level 3 (å®Œæ•´éªŒè¯) for most development work
   - Use Level 1-2 for rapid iteration during development
   - Reserve Level 4 for pre-commit/pre-PR validation
   - If unsure which level to use, default to Level 3
   - Build (`npm run build`) should only run in CI/CD or when explicitly requested